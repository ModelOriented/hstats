% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pd_importance.R
\name{pd_importance}
\alias{pd_importance}
\alias{pd_importance.default}
\alias{pd_importance.ranger}
\alias{pd_importance.Learner}
\title{PD Importance}
\usage{
pd_importance(object, ...)

\method{pd_importance}{default}(
  object,
  v,
  X,
  pred_fun = stats::predict,
  n_max = 300L,
  w = NULL,
  verbose = TRUE,
  ...
)

\method{pd_importance}{ranger}(
  object,
  v,
  X,
  pred_fun = function(m, X, ...) stats::predict(m, X, ...)$predictions,
  n_max = 300L,
  w = NULL,
  verbose = TRUE,
  ...
)

\method{pd_importance}{Learner}(
  object,
  v,
  X,
  pred_fun = function(m, X) m$predict_newdata(X)$response,
  n_max = 300L,
  w = NULL,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{object}{Fitted model object.}

\item{...}{Additional arguments passed to \code{pred_fun(object, X, ...)}.}

\item{v}{Vector or list of feature names. If passed as list, \emph{vectors} of feature
names are evaluted together. These vectors can be named for better readability of
results.}

\item{X}{A data.frame or matrix serving as background dataset.}

\item{pred_fun}{Prediction function of the form \verb{function(object, X, ...)},
providing K >= 1 numeric predictions per row. Its first argument represents the
model \code{object}, its second argument a data structure like \code{X}. Additional arguments
(such as \code{type = "response"} in a GLM) can be passed via \code{...}. The default,
\code{\link[stats:predict]{stats::predict()}}, will work in most cases. Note that column names in a resulting
matrix of predictions will be used as default column names in the results.}

\item{n_max}{If \code{X} has more than \code{n_max} rows, a random sample of \code{n_max} rows is
selected for calculations (after determining \code{grid}).}

\item{w}{Optional vector of case weights for each row of \code{X}.}

\item{verbose}{Should a progress bar be shown? The default is \code{TRUE}.}
}
\value{
An object of class "pd_importance", containing these elements:
\itemize{
\item \code{imp}: Matrix with importance values per element of \code{v}.
\item \code{v}: Same as input \code{v}.
}
}
\description{
The sample variance of the partial dependence function \eqn{\textrm{PD}_{j}} of
feature \eqn{X^{(j)}} evaluated over a data set \eqn{D} can be used as measure
of \strong{main effect importance}, defined as
\deqn{\textrm{PDI}(j, D) = \textrm{Var}\left(\sum_{i \in D} \textrm{PD}_{j}(x_i^{(j)})\right)}.
Similarly, we can define the PD importance of two or more features together,
measuring their joint effect (main effects plus interaction). Note that Friedman's H
(see \code{\link[=pd_interaction]{pd_interaction()}}) uses a similar construction, but there the focus is on pure
interaction effects (combined effects minus main effects).
}
\section{Methods (by class)}{
\itemize{
\item \code{pd_importance(default)}: Default method.

\item \code{pd_importance(ranger)}: Method for "ranger" models
.

\item \code{pd_importance(Learner)}: Method for "mlr3" models.

}}
\examples{
# MODEL ONE: Linear regression
fit <- lm(Sepal.Length ~ ., data = iris)
imp <- pd_importance(fit, v = names(iris[-1]), X = iris, verbose = FALSE)
imp
summary(imp)

# With groups of variables
v <- list("Sepal.Width", Petal = c("Petal.Width", "Petal.Length"), "Species")
imp <- pd_importance(fit, v = v, X = iris, verbose = FALSE)
summary(imp, out_names = "Importance")

# MODEL TWO: Multi-response linear regression
fit <- lm(as.matrix(iris[1:2]) ~ Petal.Length + Petal.Width + Species, data = iris)
v <- c("Petal.Length", "Petal.Width", "Species")
summary(imp <- pd_importance(fit, v = v, X = iris))

# MODEL THREE: matrix interface
X <- model.matrix(Sepal.Length ~ ., data = iris)
fit <- lm.fit(x = X, y = iris$Sepal.Length)
v <- list("Sepal.Width", "Petal.Length", "Petal.Width", 
          Species = c("Speciesversicolor", "Speciesvirginica"))
pred_fun <- function(m, x) c(tcrossprod(coef(m), x))
imp <- pd_importance(fit, v = v, X = X, pred_fun = pred_fun, verbose = FALSE)
summary(imp)
}
